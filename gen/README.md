<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# gen

```go
import "github.com/periaate/blume/gen"
```

Package gen implements generic types and functional forms which make use of them.

\#\# TODO

- \[ \] Support for error handling.
- \[ \] Functional forms for nested types.

## Index

- [func Comp\[A any\]\(fn Comparator\[A\]\) func\(...A\) Predicate\[A\]](<#Comp>)
- [func Ignore\[A, B any\]\(a A, \_ B\) A](<#Ignore>)
- [func Ignores\[A, B, C any\]\(fn func\(A\) \(B, C\)\) func\(A\) B](<#Ignores>)
- [func Join\[A any\]\(a ...\[\]A\) \(res \[\]A\)](<#Join>)
- [func Must\[A any\]\(a A, err error\) A](<#Must>)
- [func Product\[A any\]\(a \[\]A, B \[\]A\) \(res \[\]\[2\]A\)](<#Product>)
- [func Reverse\[A any\]\(arr \[\]A\) \(res \[\]A\)](<#Reverse>)
- [func Reverses\[A any\]\(arr \[\]A\)](<#Reverses>)
- [func V\[A any\]\(a ...A\) \[\]A](<#V>)
- [type Comparator](<#Comparator>)
  - [func Negate\[T any\]\(fn Comparator\[T\]\) Comparator\[T\]](<#Negate>)
- [type Dyadic](<#Dyadic>)
- [type Mapper](<#Mapper>)
  - [func Filter\[A any\]\(fn Predicate\[A\]\) Mapper\[A, A\]](<#Filter>)
  - [func Map\[A, B any\]\(fn func\(A\) B\) Mapper\[A, B\]](<#Map>)
- [type Monadic](<#Monadic>)
  - [func Cat\[A, B, C any\]\(a Monadic\[A, B\], b Monadic\[B, C\]\) Monadic\[A, C\]](<#Cat>)
  - [func Thunk\[A, B any\]\(fn Monadic\[A, B\]\) Monadic\[A, Niladic\[B\]\]](<#Thunk>)
- [type Niladic](<#Niladic>)
- [type Predicate](<#Predicate>)
  - [func And\[A any\]\(fns ...Predicate\[A\]\) Predicate\[A\]](<#And>)
  - [func Deduplicate\[A any, C comparable\]\(fn func\(A\) C\) Predicate\[A\]](<#Deduplicate>)
  - [func Is\[C comparable\]\(A ...C\) Predicate\[C\]](<#Is>)
  - [func Isnt\[C comparable\]\(A ...C\) Predicate\[C\]](<#Isnt>)
  - [func Not\[T any\]\(fn Predicate\[T\]\) Predicate\[T\]](<#Not>)
  - [func Or\[A any\]\(fns ...Predicate\[A\]\) Predicate\[A\]](<#Or>)
- [type Reducer](<#Reducer>)
  - [func All\[A any\]\(fn Predicate\[A\]\) Reducer\[A, bool\]](<#All>)
  - [func Any\[A any\]\(fn Predicate\[A\]\) Reducer\[A, bool\]](<#Any>)
  - [func Reduce\[A any, B any\]\(fn Dyadic\[B, A, B\], init B\) Reducer\[A, B\]](<#Reduce>)
- [type Transformer](<#Transformer>)
  - [func Middleware\[A, B any\]\(mw func\(A\)\) Transformer\[Monadic\[A, B\]\]](<#Middleware>)
  - [func Pipe\[A any\]\(fns ...Transformer\[A\]\) Transformer\[A\]](<#Pipe>)


<a name="Comp"></a>
## func Comp

```go
func Comp[A any](fn Comparator[A]) func(...A) Predicate[A]
```

Comp takes a [Comparator](<#Comparator>), variadic arguments, and returns a [Predicate](<#Predicate>). If any of the arguments pass the [Comparator](<#Comparator>), the [Predicate](<#Predicate>) returns true.

<a name="Ignore"></a>
## func Ignore

```go
func Ignore[A, B any](a A, _ B) A
```

Ignore returns the first argument and ignores the second.

<a name="Ignores"></a>
## func Ignores

```go
func Ignores[A, B, C any](fn func(A) (B, C)) func(A) B
```

Ignores transforms a function from F : A \-\> \(B, C\) to [Monadic](<#Monadic>) F : A \-\> B.

<a name="Join"></a>
## func Join

```go
func Join[A any](a ...[]A) (res []A)
```

Join multiple slices into a new slice.

<a name="Must"></a>
## func Must

```go
func Must[A any](a A, err error) A
```

Must panics if the error is not nil.

<a name="Product"></a>
## func Product

```go
func Product[A any](a []A, B []A) (res [][2]A)
```

Product returns the cartesian product of two slices.

<a name="Reverse"></a>
## func Reverse

```go
func Reverse[A any](arr []A) (res []A)
```

Reverse copies and reverses the given slice.

<a name="Reverses"></a>
## func Reverses

```go
func Reverses[A any](arr []A)
```

Reverses the given slice in place.

<a name="V"></a>
## func V

```go
func V[A any](a ...A) []A
```

V turns variadic arguments into a slice.

<a name="Comparator"></a>
## type Comparator

Comparator is a function that compares two arguments.

```go
type Comparator[A any] Dyadic[A, A, bool]
```

<a name="Negate"></a>
### func Negate

```go
func Negate[T any](fn Comparator[T]) Comparator[T]
```

Negate negates a [Comparator](<#Comparator>).

<a name="Dyadic"></a>
## type Dyadic

Dyadic is a function that takes two arguments and returns a single value.

```go
type Dyadic[A, B, C any] func(A, B) C
```

<a name="Mapper"></a>
## type Mapper

Mapper is a function that takes variadic arguments and returns a slice.

```go
type Mapper[A, B any] Monadic[[]A, []B]
```

<a name="Filter"></a>
### func Filter

```go
func Filter[A any](fn Predicate[A]) Mapper[A, A]
```

Filter returns a slice of arguments that pass the [Predicate](<#Predicate>).

<a name="Map"></a>
### func Map

```go
func Map[A, B any](fn func(A) B) Mapper[A, B]
```

Map applies the function to each argument and returns the results.

<a name="Monadic"></a>
## type Monadic

Monadic is a function that takes a single argument and returns a single value.

```go
type Monadic[A, B any] func(A) B
```

<a name="Cat"></a>
### func Cat

```go
func Cat[A, B, C any](a Monadic[A, B], b Monadic[B, C]) Monadic[A, C]
```

Cat concatenates two [Monadic](<#Monadic>) functions into a single [Monadic](<#Monadic>) function.

<a name="Thunk"></a>
### func Thunk

```go
func Thunk[A, B any](fn Monadic[A, B]) Monadic[A, Niladic[B]]
```

Thunk takes a [Monadic](<#Monadic>) function, its argument, and returns a [Niladic](<#Niladic>) function. When the [Niladic](<#Niladic>) function is called, it will call the [Monadic](<#Monadic>) function with the argument.

<a name="Niladic"></a>
## type Niladic

Niladic is a function that takes no arguments and returns a single value.

```go
type Niladic[A any] func() A
```

<a name="Predicate"></a>
## type Predicate

Predicate is a function that takes a single argument and returns a boolean.

```go
type Predicate[A any] Monadic[A, bool]
```

<a name="And"></a>
### func And

```go
func And[A any](fns ...Predicate[A]) Predicate[A]
```

And combines variadic \[Predicate\]s with an AND operation.

<a name="Deduplicate"></a>
### func Deduplicate

```go
func Deduplicate[A any, C comparable](fn func(A) C) Predicate[A]
```

Deduplicate returns a predicate that filters out duplicates based on the given function.

<a name="Is"></a>
### func Is

```go
func Is[C comparable](A ...C) Predicate[C]
```

Is returns a [Predicate](<#Predicate>) that checks if the argument is in the list.

<a name="Isnt"></a>
### func Isnt

```go
func Isnt[C comparable](A ...C) Predicate[C]
```

Isnt returns a [Predicate](<#Predicate>) that checks if the argument is not in the list.

<a name="Not"></a>
### func Not

```go
func Not[T any](fn Predicate[T]) Predicate[T]
```

Not negates a [Predicate](<#Predicate>).

<a name="Or"></a>
### func Or

```go
func Or[A any](fns ...Predicate[A]) Predicate[A]
```

Or combines variadic \[Predicate\]s with an OR operation.

<a name="Reducer"></a>
## type Reducer

Reducer is a function that takes variadic arguments and returns a single value.

```go
type Reducer[A, B any] Monadic[[]A, B]
```

<a name="All"></a>
### func All

```go
func All[A any](fn Predicate[A]) Reducer[A, bool]
```

All returns true if all arguments pass the [Predicate](<#Predicate>).

<a name="Any"></a>
### func Any

```go
func Any[A any](fn Predicate[A]) Reducer[A, bool]
```

Any returns true if any argument passes the [Predicate](<#Predicate>).

<a name="Reduce"></a>
### func Reduce

```go
func Reduce[A any, B any](fn Dyadic[B, A, B], init B) Reducer[A, B]
```

Reduce applies the function to each argument and returns the result.

<a name="Transformer"></a>
## type Transformer

Transformer is a function that takes a single argument and returns a modified value.

```go
type Transformer[A any] Monadic[A, A]
```

<a name="Middleware"></a>
### func Middleware

```go
func Middleware[A, B any](mw func(A)) Transformer[Monadic[A, B]]
```

Middleware wraps a function with a middleware, calling it before the next function.

<a name="Pipe"></a>
### func Pipe

```go
func Pipe[A any](fns ...Transformer[A]) Transformer[A]
```

Pipe combines variadic \[Transformer\]s into a single [Transformer](<#Transformer>).

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
