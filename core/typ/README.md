<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# typ

```go
import "github.com/periaate/blume/core/typ"
```

## Index

- [func AND\[N num.Unsigned\]\(a, b N\) N](<#AND>)
- [func Deduplicate\[A any, C comparable\]\(fn func\(A\) C\) gen.Predicate\[A\]](<#Deduplicate>)
- [func HAS\[N num.Unsigned\]\(a, b N\) bool](<#HAS>)
- [func Include\[N num.Unsigned\]\(src N, args ...N\) N](<#Include>)
- [func Invert\[K, V comparable\]\(m map\[K\]V\) \(res map\[V\]\[\]K\)](<#Invert>)
- [func InvertAny\[K, C comparable, V any\]\(fn func\(V\) C\) func\(map\[K\]V\) map\[C\]\[\]K](<#InvertAny>)
- [func Join\[T any\]\(a ...\[\]T\) \(res \[\]T\)](<#Join>)
- [func Keys\[K comparable, V any\]\(m map\[K\]V\) \[\]K](<#Keys>)
- [func NOT\[N num.Unsigned\]\(a, b N\) N](<#NOT>)
- [func OR\[N num.Unsigned\]\(a, b N\) N](<#OR>)
- [func Product\[T any\]\(a \[\]T, B \[\]T\) \(res \[\]\[2\]T\)](<#Product>)
- [func Reverse\[T any\]\(arr \[\]T\)](<#Reverse>)
- [func ReverseC\[T any\]\(arr \[\]T\) \(res \[\]T\)](<#ReverseC>)
- [func Vals\[K comparable, V any\]\(m map\[K\]V\) \[\]V](<#Vals>)
- [func XOR\[N num.Unsigned\]\(a, b N\) N](<#XOR>)
- [type BitField](<#BitField>)
  - [func \(bf \*BitField\[K, N\]\) Alias\(n N, keys ...K\)](<#BitField[K, N].Alias>)
  - [func \(bf \*BitField\[K, N\]\) WithKey\(args ...K\) \(res N\)](<#BitField[K, N].WithKey>)


<a name="AND"></a>
## func AND

```go
func AND[N num.Unsigned](a, b N) N
```



<a name="Deduplicate"></a>
## func Deduplicate

```go
func Deduplicate[A any, C comparable](fn func(A) C) gen.Predicate[A]
```

Deduplicate returns a predicate that filters out duplicates based on the given function.

<a name="HAS"></a>
## func HAS

```go
func HAS[N num.Unsigned](a, b N) bool
```



<a name="Include"></a>
## func Include

```go
func Include[N num.Unsigned](src N, args ...N) N
```



<a name="Invert"></a>
## func Invert

```go
func Invert[K, V comparable](m map[K]V) (res map[V][]K)
```

Invert creates and inverted index of the given map.

<a name="InvertAny"></a>
## func InvertAny

```go
func InvertAny[K, C comparable, V any](fn func(V) C) func(map[K]V) map[C][]K
```

InvertAny creates and inverted index of the given map using a custom function.

<a name="Join"></a>
## func Join

```go
func Join[T any](a ...[]T) (res []T)
```

Join multiple slices into a new slice.

<a name="Keys"></a>
## func Keys

```go
func Keys[K comparable, V any](m map[K]V) []K
```

Keys returns the keys of the given map.

<a name="NOT"></a>
## func NOT

```go
func NOT[N num.Unsigned](a, b N) N
```



<a name="OR"></a>
## func OR

```go
func OR[N num.Unsigned](a, b N) N
```



<a name="Product"></a>
## func Product

```go
func Product[T any](a []T, B []T) (res [][2]T)
```

Product returns the cartesian product of two slices.

<a name="Reverse"></a>
## func Reverse

```go
func Reverse[T any](arr []T)
```

Reverse reverses the given slice in place.

<a name="ReverseC"></a>
## func ReverseC

```go
func ReverseC[T any](arr []T) (res []T)
```

ReverseC copies and reverses the given slice.

<a name="Vals"></a>
## func Vals

```go
func Vals[K comparable, V any](m map[K]V) []V
```

Vals returns the values of the given map.

<a name="XOR"></a>
## func XOR

```go
func XOR[N num.Unsigned](a, b N) N
```



<a name="BitField"></a>
## type BitField



```go
type BitField[K comparable, N num.Unsigned] struct {
    Aliases map[K]N
}
```

<a name="BitField[K, N].Alias"></a>
### func \(\*BitField\[K, N\]\) Alias

```go
func (bf *BitField[K, N]) Alias(n N, keys ...K)
```



<a name="BitField[K, N].WithKey"></a>
### func \(\*BitField\[K, N\]\) WithKey

```go
func (bf *BitField[K, N]) WithKey(args ...K) (res N)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
